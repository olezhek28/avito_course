package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/olezhek28/avito_course/hw12_13_14_15_calendar/internal/app/repository.EventRepository -o ./mocks/event_repository_minimock.go -n EventRepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/olezhek28/avito_course/hw12_13_14_15_calendar/internal/app/model"
)

// EventRepositoryMock implements repository.EventRepository
type EventRepositoryMock struct {
	t minimock.Tester

	funcCreateEvent          func(ctx context.Context, eventInfo *model.EventInfo) (err error)
	inspectFuncCreateEvent   func(ctx context.Context, eventInfo *model.EventInfo)
	afterCreateEventCounter  uint64
	beforeCreateEventCounter uint64
	CreateEventMock          mEventRepositoryMockCreateEvent

	funcDeleteEvent          func(ctx context.Context, eventID int64) (err error)
	inspectFuncDeleteEvent   func(ctx context.Context, eventID int64)
	afterDeleteEventCounter  uint64
	beforeDeleteEventCounter uint64
	DeleteEventMock          mEventRepositoryMockDeleteEvent

	funcGetEventListByDate          func(ctx context.Context, startDate time.Time, endDate time.Time) (epa1 []*model.Event, err error)
	inspectFuncGetEventListByDate   func(ctx context.Context, startDate time.Time, endDate time.Time)
	afterGetEventListByDateCounter  uint64
	beforeGetEventListByDateCounter uint64
	GetEventListByDateMock          mEventRepositoryMockGetEventListByDate

	funcGetEventListForDay          func(ctx context.Context, date time.Time) (epa1 []*model.Event, err error)
	inspectFuncGetEventListForDay   func(ctx context.Context, date time.Time)
	afterGetEventListForDayCounter  uint64
	beforeGetEventListForDayCounter uint64
	GetEventListForDayMock          mEventRepositoryMockGetEventListForDay

	funcGetEventListForMonth          func(ctx context.Context, monthStart time.Time) (epa1 []*model.Event, err error)
	inspectFuncGetEventListForMonth   func(ctx context.Context, monthStart time.Time)
	afterGetEventListForMonthCounter  uint64
	beforeGetEventListForMonthCounter uint64
	GetEventListForMonthMock          mEventRepositoryMockGetEventListForMonth

	funcGetEventListForWeek          func(ctx context.Context, weekStart time.Time) (epa1 []*model.Event, err error)
	inspectFuncGetEventListForWeek   func(ctx context.Context, weekStart time.Time)
	afterGetEventListForWeekCounter  uint64
	beforeGetEventListForWeekCounter uint64
	GetEventListForWeekMock          mEventRepositoryMockGetEventListForWeek

	funcUpdateEvent          func(ctx context.Context, eventID int64, updateEventInfo *model.UpdateEventInfo) (err error)
	inspectFuncUpdateEvent   func(ctx context.Context, eventID int64, updateEventInfo *model.UpdateEventInfo)
	afterUpdateEventCounter  uint64
	beforeUpdateEventCounter uint64
	UpdateEventMock          mEventRepositoryMockUpdateEvent
}

// NewEventRepositoryMock returns a mock for repository.EventRepository
func NewEventRepositoryMock(t minimock.Tester) *EventRepositoryMock {
	m := &EventRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateEventMock = mEventRepositoryMockCreateEvent{mock: m}
	m.CreateEventMock.callArgs = []*EventRepositoryMockCreateEventParams{}

	m.DeleteEventMock = mEventRepositoryMockDeleteEvent{mock: m}
	m.DeleteEventMock.callArgs = []*EventRepositoryMockDeleteEventParams{}

	m.GetEventListByDateMock = mEventRepositoryMockGetEventListByDate{mock: m}
	m.GetEventListByDateMock.callArgs = []*EventRepositoryMockGetEventListByDateParams{}

	m.GetEventListForDayMock = mEventRepositoryMockGetEventListForDay{mock: m}
	m.GetEventListForDayMock.callArgs = []*EventRepositoryMockGetEventListForDayParams{}

	m.GetEventListForMonthMock = mEventRepositoryMockGetEventListForMonth{mock: m}
	m.GetEventListForMonthMock.callArgs = []*EventRepositoryMockGetEventListForMonthParams{}

	m.GetEventListForWeekMock = mEventRepositoryMockGetEventListForWeek{mock: m}
	m.GetEventListForWeekMock.callArgs = []*EventRepositoryMockGetEventListForWeekParams{}

	m.UpdateEventMock = mEventRepositoryMockUpdateEvent{mock: m}
	m.UpdateEventMock.callArgs = []*EventRepositoryMockUpdateEventParams{}

	return m
}

type mEventRepositoryMockCreateEvent struct {
	mock               *EventRepositoryMock
	defaultExpectation *EventRepositoryMockCreateEventExpectation
	expectations       []*EventRepositoryMockCreateEventExpectation

	callArgs []*EventRepositoryMockCreateEventParams
	mutex    sync.RWMutex
}

// EventRepositoryMockCreateEventExpectation specifies expectation struct of the EventRepository.CreateEvent
type EventRepositoryMockCreateEventExpectation struct {
	mock    *EventRepositoryMock
	params  *EventRepositoryMockCreateEventParams
	results *EventRepositoryMockCreateEventResults
	Counter uint64
}

// EventRepositoryMockCreateEventParams contains parameters of the EventRepository.CreateEvent
type EventRepositoryMockCreateEventParams struct {
	ctx       context.Context
	eventInfo *model.EventInfo
}

// EventRepositoryMockCreateEventResults contains results of the EventRepository.CreateEvent
type EventRepositoryMockCreateEventResults struct {
	err error
}

// Expect sets up expected params for EventRepository.CreateEvent
func (mmCreateEvent *mEventRepositoryMockCreateEvent) Expect(ctx context.Context, eventInfo *model.EventInfo) *mEventRepositoryMockCreateEvent {
	if mmCreateEvent.mock.funcCreateEvent != nil {
		mmCreateEvent.mock.t.Fatalf("EventRepositoryMock.CreateEvent mock is already set by Set")
	}

	if mmCreateEvent.defaultExpectation == nil {
		mmCreateEvent.defaultExpectation = &EventRepositoryMockCreateEventExpectation{}
	}

	mmCreateEvent.defaultExpectation.params = &EventRepositoryMockCreateEventParams{ctx, eventInfo}
	for _, e := range mmCreateEvent.expectations {
		if minimock.Equal(e.params, mmCreateEvent.defaultExpectation.params) {
			mmCreateEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateEvent.defaultExpectation.params)
		}
	}

	return mmCreateEvent
}

// Inspect accepts an inspector function that has same arguments as the EventRepository.CreateEvent
func (mmCreateEvent *mEventRepositoryMockCreateEvent) Inspect(f func(ctx context.Context, eventInfo *model.EventInfo)) *mEventRepositoryMockCreateEvent {
	if mmCreateEvent.mock.inspectFuncCreateEvent != nil {
		mmCreateEvent.mock.t.Fatalf("Inspect function is already set for EventRepositoryMock.CreateEvent")
	}

	mmCreateEvent.mock.inspectFuncCreateEvent = f

	return mmCreateEvent
}

// Return sets up results that will be returned by EventRepository.CreateEvent
func (mmCreateEvent *mEventRepositoryMockCreateEvent) Return(err error) *EventRepositoryMock {
	if mmCreateEvent.mock.funcCreateEvent != nil {
		mmCreateEvent.mock.t.Fatalf("EventRepositoryMock.CreateEvent mock is already set by Set")
	}

	if mmCreateEvent.defaultExpectation == nil {
		mmCreateEvent.defaultExpectation = &EventRepositoryMockCreateEventExpectation{mock: mmCreateEvent.mock}
	}
	mmCreateEvent.defaultExpectation.results = &EventRepositoryMockCreateEventResults{err}
	return mmCreateEvent.mock
}

//Set uses given function f to mock the EventRepository.CreateEvent method
func (mmCreateEvent *mEventRepositoryMockCreateEvent) Set(f func(ctx context.Context, eventInfo *model.EventInfo) (err error)) *EventRepositoryMock {
	if mmCreateEvent.defaultExpectation != nil {
		mmCreateEvent.mock.t.Fatalf("Default expectation is already set for the EventRepository.CreateEvent method")
	}

	if len(mmCreateEvent.expectations) > 0 {
		mmCreateEvent.mock.t.Fatalf("Some expectations are already set for the EventRepository.CreateEvent method")
	}

	mmCreateEvent.mock.funcCreateEvent = f
	return mmCreateEvent.mock
}

// When sets expectation for the EventRepository.CreateEvent which will trigger the result defined by the following
// Then helper
func (mmCreateEvent *mEventRepositoryMockCreateEvent) When(ctx context.Context, eventInfo *model.EventInfo) *EventRepositoryMockCreateEventExpectation {
	if mmCreateEvent.mock.funcCreateEvent != nil {
		mmCreateEvent.mock.t.Fatalf("EventRepositoryMock.CreateEvent mock is already set by Set")
	}

	expectation := &EventRepositoryMockCreateEventExpectation{
		mock:   mmCreateEvent.mock,
		params: &EventRepositoryMockCreateEventParams{ctx, eventInfo},
	}
	mmCreateEvent.expectations = append(mmCreateEvent.expectations, expectation)
	return expectation
}

// Then sets up EventRepository.CreateEvent return parameters for the expectation previously defined by the When method
func (e *EventRepositoryMockCreateEventExpectation) Then(err error) *EventRepositoryMock {
	e.results = &EventRepositoryMockCreateEventResults{err}
	return e.mock
}

// CreateEvent implements repository.EventRepository
func (mmCreateEvent *EventRepositoryMock) CreateEvent(ctx context.Context, eventInfo *model.EventInfo) (err error) {
	mm_atomic.AddUint64(&mmCreateEvent.beforeCreateEventCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateEvent.afterCreateEventCounter, 1)

	if mmCreateEvent.inspectFuncCreateEvent != nil {
		mmCreateEvent.inspectFuncCreateEvent(ctx, eventInfo)
	}

	mm_params := &EventRepositoryMockCreateEventParams{ctx, eventInfo}

	// Record call args
	mmCreateEvent.CreateEventMock.mutex.Lock()
	mmCreateEvent.CreateEventMock.callArgs = append(mmCreateEvent.CreateEventMock.callArgs, mm_params)
	mmCreateEvent.CreateEventMock.mutex.Unlock()

	for _, e := range mmCreateEvent.CreateEventMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateEvent.CreateEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateEvent.CreateEventMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateEvent.CreateEventMock.defaultExpectation.params
		mm_got := EventRepositoryMockCreateEventParams{ctx, eventInfo}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateEvent.t.Errorf("EventRepositoryMock.CreateEvent got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateEvent.CreateEventMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateEvent.t.Fatal("No results are set for the EventRepositoryMock.CreateEvent")
		}
		return (*mm_results).err
	}
	if mmCreateEvent.funcCreateEvent != nil {
		return mmCreateEvent.funcCreateEvent(ctx, eventInfo)
	}
	mmCreateEvent.t.Fatalf("Unexpected call to EventRepositoryMock.CreateEvent. %v %v", ctx, eventInfo)
	return
}

// CreateEventAfterCounter returns a count of finished EventRepositoryMock.CreateEvent invocations
func (mmCreateEvent *EventRepositoryMock) CreateEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateEvent.afterCreateEventCounter)
}

// CreateEventBeforeCounter returns a count of EventRepositoryMock.CreateEvent invocations
func (mmCreateEvent *EventRepositoryMock) CreateEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateEvent.beforeCreateEventCounter)
}

// Calls returns a list of arguments used in each call to EventRepositoryMock.CreateEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateEvent *mEventRepositoryMockCreateEvent) Calls() []*EventRepositoryMockCreateEventParams {
	mmCreateEvent.mutex.RLock()

	argCopy := make([]*EventRepositoryMockCreateEventParams, len(mmCreateEvent.callArgs))
	copy(argCopy, mmCreateEvent.callArgs)

	mmCreateEvent.mutex.RUnlock()

	return argCopy
}

// MinimockCreateEventDone returns true if the count of the CreateEvent invocations corresponds
// the number of defined expectations
func (m *EventRepositoryMock) MinimockCreateEventDone() bool {
	for _, e := range m.CreateEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateEventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateEventCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateEvent != nil && mm_atomic.LoadUint64(&m.afterCreateEventCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateEventInspect logs each unmet expectation
func (m *EventRepositoryMock) MinimockCreateEventInspect() {
	for _, e := range m.CreateEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EventRepositoryMock.CreateEvent with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateEventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateEventCounter) < 1 {
		if m.CreateEventMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EventRepositoryMock.CreateEvent")
		} else {
			m.t.Errorf("Expected call to EventRepositoryMock.CreateEvent with params: %#v", *m.CreateEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateEvent != nil && mm_atomic.LoadUint64(&m.afterCreateEventCounter) < 1 {
		m.t.Error("Expected call to EventRepositoryMock.CreateEvent")
	}
}

type mEventRepositoryMockDeleteEvent struct {
	mock               *EventRepositoryMock
	defaultExpectation *EventRepositoryMockDeleteEventExpectation
	expectations       []*EventRepositoryMockDeleteEventExpectation

	callArgs []*EventRepositoryMockDeleteEventParams
	mutex    sync.RWMutex
}

// EventRepositoryMockDeleteEventExpectation specifies expectation struct of the EventRepository.DeleteEvent
type EventRepositoryMockDeleteEventExpectation struct {
	mock    *EventRepositoryMock
	params  *EventRepositoryMockDeleteEventParams
	results *EventRepositoryMockDeleteEventResults
	Counter uint64
}

// EventRepositoryMockDeleteEventParams contains parameters of the EventRepository.DeleteEvent
type EventRepositoryMockDeleteEventParams struct {
	ctx     context.Context
	eventID int64
}

// EventRepositoryMockDeleteEventResults contains results of the EventRepository.DeleteEvent
type EventRepositoryMockDeleteEventResults struct {
	err error
}

// Expect sets up expected params for EventRepository.DeleteEvent
func (mmDeleteEvent *mEventRepositoryMockDeleteEvent) Expect(ctx context.Context, eventID int64) *mEventRepositoryMockDeleteEvent {
	if mmDeleteEvent.mock.funcDeleteEvent != nil {
		mmDeleteEvent.mock.t.Fatalf("EventRepositoryMock.DeleteEvent mock is already set by Set")
	}

	if mmDeleteEvent.defaultExpectation == nil {
		mmDeleteEvent.defaultExpectation = &EventRepositoryMockDeleteEventExpectation{}
	}

	mmDeleteEvent.defaultExpectation.params = &EventRepositoryMockDeleteEventParams{ctx, eventID}
	for _, e := range mmDeleteEvent.expectations {
		if minimock.Equal(e.params, mmDeleteEvent.defaultExpectation.params) {
			mmDeleteEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteEvent.defaultExpectation.params)
		}
	}

	return mmDeleteEvent
}

// Inspect accepts an inspector function that has same arguments as the EventRepository.DeleteEvent
func (mmDeleteEvent *mEventRepositoryMockDeleteEvent) Inspect(f func(ctx context.Context, eventID int64)) *mEventRepositoryMockDeleteEvent {
	if mmDeleteEvent.mock.inspectFuncDeleteEvent != nil {
		mmDeleteEvent.mock.t.Fatalf("Inspect function is already set for EventRepositoryMock.DeleteEvent")
	}

	mmDeleteEvent.mock.inspectFuncDeleteEvent = f

	return mmDeleteEvent
}

// Return sets up results that will be returned by EventRepository.DeleteEvent
func (mmDeleteEvent *mEventRepositoryMockDeleteEvent) Return(err error) *EventRepositoryMock {
	if mmDeleteEvent.mock.funcDeleteEvent != nil {
		mmDeleteEvent.mock.t.Fatalf("EventRepositoryMock.DeleteEvent mock is already set by Set")
	}

	if mmDeleteEvent.defaultExpectation == nil {
		mmDeleteEvent.defaultExpectation = &EventRepositoryMockDeleteEventExpectation{mock: mmDeleteEvent.mock}
	}
	mmDeleteEvent.defaultExpectation.results = &EventRepositoryMockDeleteEventResults{err}
	return mmDeleteEvent.mock
}

//Set uses given function f to mock the EventRepository.DeleteEvent method
func (mmDeleteEvent *mEventRepositoryMockDeleteEvent) Set(f func(ctx context.Context, eventID int64) (err error)) *EventRepositoryMock {
	if mmDeleteEvent.defaultExpectation != nil {
		mmDeleteEvent.mock.t.Fatalf("Default expectation is already set for the EventRepository.DeleteEvent method")
	}

	if len(mmDeleteEvent.expectations) > 0 {
		mmDeleteEvent.mock.t.Fatalf("Some expectations are already set for the EventRepository.DeleteEvent method")
	}

	mmDeleteEvent.mock.funcDeleteEvent = f
	return mmDeleteEvent.mock
}

// When sets expectation for the EventRepository.DeleteEvent which will trigger the result defined by the following
// Then helper
func (mmDeleteEvent *mEventRepositoryMockDeleteEvent) When(ctx context.Context, eventID int64) *EventRepositoryMockDeleteEventExpectation {
	if mmDeleteEvent.mock.funcDeleteEvent != nil {
		mmDeleteEvent.mock.t.Fatalf("EventRepositoryMock.DeleteEvent mock is already set by Set")
	}

	expectation := &EventRepositoryMockDeleteEventExpectation{
		mock:   mmDeleteEvent.mock,
		params: &EventRepositoryMockDeleteEventParams{ctx, eventID},
	}
	mmDeleteEvent.expectations = append(mmDeleteEvent.expectations, expectation)
	return expectation
}

// Then sets up EventRepository.DeleteEvent return parameters for the expectation previously defined by the When method
func (e *EventRepositoryMockDeleteEventExpectation) Then(err error) *EventRepositoryMock {
	e.results = &EventRepositoryMockDeleteEventResults{err}
	return e.mock
}

// DeleteEvent implements repository.EventRepository
func (mmDeleteEvent *EventRepositoryMock) DeleteEvent(ctx context.Context, eventID int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteEvent.beforeDeleteEventCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteEvent.afterDeleteEventCounter, 1)

	if mmDeleteEvent.inspectFuncDeleteEvent != nil {
		mmDeleteEvent.inspectFuncDeleteEvent(ctx, eventID)
	}

	mm_params := &EventRepositoryMockDeleteEventParams{ctx, eventID}

	// Record call args
	mmDeleteEvent.DeleteEventMock.mutex.Lock()
	mmDeleteEvent.DeleteEventMock.callArgs = append(mmDeleteEvent.DeleteEventMock.callArgs, mm_params)
	mmDeleteEvent.DeleteEventMock.mutex.Unlock()

	for _, e := range mmDeleteEvent.DeleteEventMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteEvent.DeleteEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteEvent.DeleteEventMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteEvent.DeleteEventMock.defaultExpectation.params
		mm_got := EventRepositoryMockDeleteEventParams{ctx, eventID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteEvent.t.Errorf("EventRepositoryMock.DeleteEvent got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteEvent.DeleteEventMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteEvent.t.Fatal("No results are set for the EventRepositoryMock.DeleteEvent")
		}
		return (*mm_results).err
	}
	if mmDeleteEvent.funcDeleteEvent != nil {
		return mmDeleteEvent.funcDeleteEvent(ctx, eventID)
	}
	mmDeleteEvent.t.Fatalf("Unexpected call to EventRepositoryMock.DeleteEvent. %v %v", ctx, eventID)
	return
}

// DeleteEventAfterCounter returns a count of finished EventRepositoryMock.DeleteEvent invocations
func (mmDeleteEvent *EventRepositoryMock) DeleteEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEvent.afterDeleteEventCounter)
}

// DeleteEventBeforeCounter returns a count of EventRepositoryMock.DeleteEvent invocations
func (mmDeleteEvent *EventRepositoryMock) DeleteEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteEvent.beforeDeleteEventCounter)
}

// Calls returns a list of arguments used in each call to EventRepositoryMock.DeleteEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteEvent *mEventRepositoryMockDeleteEvent) Calls() []*EventRepositoryMockDeleteEventParams {
	mmDeleteEvent.mutex.RLock()

	argCopy := make([]*EventRepositoryMockDeleteEventParams, len(mmDeleteEvent.callArgs))
	copy(argCopy, mmDeleteEvent.callArgs)

	mmDeleteEvent.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteEventDone returns true if the count of the DeleteEvent invocations corresponds
// the number of defined expectations
func (m *EventRepositoryMock) MinimockDeleteEventDone() bool {
	for _, e := range m.DeleteEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteEventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteEventCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteEvent != nil && mm_atomic.LoadUint64(&m.afterDeleteEventCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteEventInspect logs each unmet expectation
func (m *EventRepositoryMock) MinimockDeleteEventInspect() {
	for _, e := range m.DeleteEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EventRepositoryMock.DeleteEvent with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteEventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteEventCounter) < 1 {
		if m.DeleteEventMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EventRepositoryMock.DeleteEvent")
		} else {
			m.t.Errorf("Expected call to EventRepositoryMock.DeleteEvent with params: %#v", *m.DeleteEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteEvent != nil && mm_atomic.LoadUint64(&m.afterDeleteEventCounter) < 1 {
		m.t.Error("Expected call to EventRepositoryMock.DeleteEvent")
	}
}

type mEventRepositoryMockGetEventListByDate struct {
	mock               *EventRepositoryMock
	defaultExpectation *EventRepositoryMockGetEventListByDateExpectation
	expectations       []*EventRepositoryMockGetEventListByDateExpectation

	callArgs []*EventRepositoryMockGetEventListByDateParams
	mutex    sync.RWMutex
}

// EventRepositoryMockGetEventListByDateExpectation specifies expectation struct of the EventRepository.GetEventListByDate
type EventRepositoryMockGetEventListByDateExpectation struct {
	mock    *EventRepositoryMock
	params  *EventRepositoryMockGetEventListByDateParams
	results *EventRepositoryMockGetEventListByDateResults
	Counter uint64
}

// EventRepositoryMockGetEventListByDateParams contains parameters of the EventRepository.GetEventListByDate
type EventRepositoryMockGetEventListByDateParams struct {
	ctx       context.Context
	startDate time.Time
	endDate   time.Time
}

// EventRepositoryMockGetEventListByDateResults contains results of the EventRepository.GetEventListByDate
type EventRepositoryMockGetEventListByDateResults struct {
	epa1 []*model.Event
	err  error
}

// Expect sets up expected params for EventRepository.GetEventListByDate
func (mmGetEventListByDate *mEventRepositoryMockGetEventListByDate) Expect(ctx context.Context, startDate time.Time, endDate time.Time) *mEventRepositoryMockGetEventListByDate {
	if mmGetEventListByDate.mock.funcGetEventListByDate != nil {
		mmGetEventListByDate.mock.t.Fatalf("EventRepositoryMock.GetEventListByDate mock is already set by Set")
	}

	if mmGetEventListByDate.defaultExpectation == nil {
		mmGetEventListByDate.defaultExpectation = &EventRepositoryMockGetEventListByDateExpectation{}
	}

	mmGetEventListByDate.defaultExpectation.params = &EventRepositoryMockGetEventListByDateParams{ctx, startDate, endDate}
	for _, e := range mmGetEventListByDate.expectations {
		if minimock.Equal(e.params, mmGetEventListByDate.defaultExpectation.params) {
			mmGetEventListByDate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetEventListByDate.defaultExpectation.params)
		}
	}

	return mmGetEventListByDate
}

// Inspect accepts an inspector function that has same arguments as the EventRepository.GetEventListByDate
func (mmGetEventListByDate *mEventRepositoryMockGetEventListByDate) Inspect(f func(ctx context.Context, startDate time.Time, endDate time.Time)) *mEventRepositoryMockGetEventListByDate {
	if mmGetEventListByDate.mock.inspectFuncGetEventListByDate != nil {
		mmGetEventListByDate.mock.t.Fatalf("Inspect function is already set for EventRepositoryMock.GetEventListByDate")
	}

	mmGetEventListByDate.mock.inspectFuncGetEventListByDate = f

	return mmGetEventListByDate
}

// Return sets up results that will be returned by EventRepository.GetEventListByDate
func (mmGetEventListByDate *mEventRepositoryMockGetEventListByDate) Return(epa1 []*model.Event, err error) *EventRepositoryMock {
	if mmGetEventListByDate.mock.funcGetEventListByDate != nil {
		mmGetEventListByDate.mock.t.Fatalf("EventRepositoryMock.GetEventListByDate mock is already set by Set")
	}

	if mmGetEventListByDate.defaultExpectation == nil {
		mmGetEventListByDate.defaultExpectation = &EventRepositoryMockGetEventListByDateExpectation{mock: mmGetEventListByDate.mock}
	}
	mmGetEventListByDate.defaultExpectation.results = &EventRepositoryMockGetEventListByDateResults{epa1, err}
	return mmGetEventListByDate.mock
}

//Set uses given function f to mock the EventRepository.GetEventListByDate method
func (mmGetEventListByDate *mEventRepositoryMockGetEventListByDate) Set(f func(ctx context.Context, startDate time.Time, endDate time.Time) (epa1 []*model.Event, err error)) *EventRepositoryMock {
	if mmGetEventListByDate.defaultExpectation != nil {
		mmGetEventListByDate.mock.t.Fatalf("Default expectation is already set for the EventRepository.GetEventListByDate method")
	}

	if len(mmGetEventListByDate.expectations) > 0 {
		mmGetEventListByDate.mock.t.Fatalf("Some expectations are already set for the EventRepository.GetEventListByDate method")
	}

	mmGetEventListByDate.mock.funcGetEventListByDate = f
	return mmGetEventListByDate.mock
}

// When sets expectation for the EventRepository.GetEventListByDate which will trigger the result defined by the following
// Then helper
func (mmGetEventListByDate *mEventRepositoryMockGetEventListByDate) When(ctx context.Context, startDate time.Time, endDate time.Time) *EventRepositoryMockGetEventListByDateExpectation {
	if mmGetEventListByDate.mock.funcGetEventListByDate != nil {
		mmGetEventListByDate.mock.t.Fatalf("EventRepositoryMock.GetEventListByDate mock is already set by Set")
	}

	expectation := &EventRepositoryMockGetEventListByDateExpectation{
		mock:   mmGetEventListByDate.mock,
		params: &EventRepositoryMockGetEventListByDateParams{ctx, startDate, endDate},
	}
	mmGetEventListByDate.expectations = append(mmGetEventListByDate.expectations, expectation)
	return expectation
}

// Then sets up EventRepository.GetEventListByDate return parameters for the expectation previously defined by the When method
func (e *EventRepositoryMockGetEventListByDateExpectation) Then(epa1 []*model.Event, err error) *EventRepositoryMock {
	e.results = &EventRepositoryMockGetEventListByDateResults{epa1, err}
	return e.mock
}

// GetEventListByDate implements repository.EventRepository
func (mmGetEventListByDate *EventRepositoryMock) GetEventListByDate(ctx context.Context, startDate time.Time, endDate time.Time) (epa1 []*model.Event, err error) {
	mm_atomic.AddUint64(&mmGetEventListByDate.beforeGetEventListByDateCounter, 1)
	defer mm_atomic.AddUint64(&mmGetEventListByDate.afterGetEventListByDateCounter, 1)

	if mmGetEventListByDate.inspectFuncGetEventListByDate != nil {
		mmGetEventListByDate.inspectFuncGetEventListByDate(ctx, startDate, endDate)
	}

	mm_params := &EventRepositoryMockGetEventListByDateParams{ctx, startDate, endDate}

	// Record call args
	mmGetEventListByDate.GetEventListByDateMock.mutex.Lock()
	mmGetEventListByDate.GetEventListByDateMock.callArgs = append(mmGetEventListByDate.GetEventListByDateMock.callArgs, mm_params)
	mmGetEventListByDate.GetEventListByDateMock.mutex.Unlock()

	for _, e := range mmGetEventListByDate.GetEventListByDateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.epa1, e.results.err
		}
	}

	if mmGetEventListByDate.GetEventListByDateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetEventListByDate.GetEventListByDateMock.defaultExpectation.Counter, 1)
		mm_want := mmGetEventListByDate.GetEventListByDateMock.defaultExpectation.params
		mm_got := EventRepositoryMockGetEventListByDateParams{ctx, startDate, endDate}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetEventListByDate.t.Errorf("EventRepositoryMock.GetEventListByDate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetEventListByDate.GetEventListByDateMock.defaultExpectation.results
		if mm_results == nil {
			mmGetEventListByDate.t.Fatal("No results are set for the EventRepositoryMock.GetEventListByDate")
		}
		return (*mm_results).epa1, (*mm_results).err
	}
	if mmGetEventListByDate.funcGetEventListByDate != nil {
		return mmGetEventListByDate.funcGetEventListByDate(ctx, startDate, endDate)
	}
	mmGetEventListByDate.t.Fatalf("Unexpected call to EventRepositoryMock.GetEventListByDate. %v %v %v", ctx, startDate, endDate)
	return
}

// GetEventListByDateAfterCounter returns a count of finished EventRepositoryMock.GetEventListByDate invocations
func (mmGetEventListByDate *EventRepositoryMock) GetEventListByDateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEventListByDate.afterGetEventListByDateCounter)
}

// GetEventListByDateBeforeCounter returns a count of EventRepositoryMock.GetEventListByDate invocations
func (mmGetEventListByDate *EventRepositoryMock) GetEventListByDateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEventListByDate.beforeGetEventListByDateCounter)
}

// Calls returns a list of arguments used in each call to EventRepositoryMock.GetEventListByDate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetEventListByDate *mEventRepositoryMockGetEventListByDate) Calls() []*EventRepositoryMockGetEventListByDateParams {
	mmGetEventListByDate.mutex.RLock()

	argCopy := make([]*EventRepositoryMockGetEventListByDateParams, len(mmGetEventListByDate.callArgs))
	copy(argCopy, mmGetEventListByDate.callArgs)

	mmGetEventListByDate.mutex.RUnlock()

	return argCopy
}

// MinimockGetEventListByDateDone returns true if the count of the GetEventListByDate invocations corresponds
// the number of defined expectations
func (m *EventRepositoryMock) MinimockGetEventListByDateDone() bool {
	for _, e := range m.GetEventListByDateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetEventListByDateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetEventListByDateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetEventListByDate != nil && mm_atomic.LoadUint64(&m.afterGetEventListByDateCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetEventListByDateInspect logs each unmet expectation
func (m *EventRepositoryMock) MinimockGetEventListByDateInspect() {
	for _, e := range m.GetEventListByDateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EventRepositoryMock.GetEventListByDate with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetEventListByDateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetEventListByDateCounter) < 1 {
		if m.GetEventListByDateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EventRepositoryMock.GetEventListByDate")
		} else {
			m.t.Errorf("Expected call to EventRepositoryMock.GetEventListByDate with params: %#v", *m.GetEventListByDateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetEventListByDate != nil && mm_atomic.LoadUint64(&m.afterGetEventListByDateCounter) < 1 {
		m.t.Error("Expected call to EventRepositoryMock.GetEventListByDate")
	}
}

type mEventRepositoryMockGetEventListForDay struct {
	mock               *EventRepositoryMock
	defaultExpectation *EventRepositoryMockGetEventListForDayExpectation
	expectations       []*EventRepositoryMockGetEventListForDayExpectation

	callArgs []*EventRepositoryMockGetEventListForDayParams
	mutex    sync.RWMutex
}

// EventRepositoryMockGetEventListForDayExpectation specifies expectation struct of the EventRepository.GetEventListForDay
type EventRepositoryMockGetEventListForDayExpectation struct {
	mock    *EventRepositoryMock
	params  *EventRepositoryMockGetEventListForDayParams
	results *EventRepositoryMockGetEventListForDayResults
	Counter uint64
}

// EventRepositoryMockGetEventListForDayParams contains parameters of the EventRepository.GetEventListForDay
type EventRepositoryMockGetEventListForDayParams struct {
	ctx  context.Context
	date time.Time
}

// EventRepositoryMockGetEventListForDayResults contains results of the EventRepository.GetEventListForDay
type EventRepositoryMockGetEventListForDayResults struct {
	epa1 []*model.Event
	err  error
}

// Expect sets up expected params for EventRepository.GetEventListForDay
func (mmGetEventListForDay *mEventRepositoryMockGetEventListForDay) Expect(ctx context.Context, date time.Time) *mEventRepositoryMockGetEventListForDay {
	if mmGetEventListForDay.mock.funcGetEventListForDay != nil {
		mmGetEventListForDay.mock.t.Fatalf("EventRepositoryMock.GetEventListForDay mock is already set by Set")
	}

	if mmGetEventListForDay.defaultExpectation == nil {
		mmGetEventListForDay.defaultExpectation = &EventRepositoryMockGetEventListForDayExpectation{}
	}

	mmGetEventListForDay.defaultExpectation.params = &EventRepositoryMockGetEventListForDayParams{ctx, date}
	for _, e := range mmGetEventListForDay.expectations {
		if minimock.Equal(e.params, mmGetEventListForDay.defaultExpectation.params) {
			mmGetEventListForDay.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetEventListForDay.defaultExpectation.params)
		}
	}

	return mmGetEventListForDay
}

// Inspect accepts an inspector function that has same arguments as the EventRepository.GetEventListForDay
func (mmGetEventListForDay *mEventRepositoryMockGetEventListForDay) Inspect(f func(ctx context.Context, date time.Time)) *mEventRepositoryMockGetEventListForDay {
	if mmGetEventListForDay.mock.inspectFuncGetEventListForDay != nil {
		mmGetEventListForDay.mock.t.Fatalf("Inspect function is already set for EventRepositoryMock.GetEventListForDay")
	}

	mmGetEventListForDay.mock.inspectFuncGetEventListForDay = f

	return mmGetEventListForDay
}

// Return sets up results that will be returned by EventRepository.GetEventListForDay
func (mmGetEventListForDay *mEventRepositoryMockGetEventListForDay) Return(epa1 []*model.Event, err error) *EventRepositoryMock {
	if mmGetEventListForDay.mock.funcGetEventListForDay != nil {
		mmGetEventListForDay.mock.t.Fatalf("EventRepositoryMock.GetEventListForDay mock is already set by Set")
	}

	if mmGetEventListForDay.defaultExpectation == nil {
		mmGetEventListForDay.defaultExpectation = &EventRepositoryMockGetEventListForDayExpectation{mock: mmGetEventListForDay.mock}
	}
	mmGetEventListForDay.defaultExpectation.results = &EventRepositoryMockGetEventListForDayResults{epa1, err}
	return mmGetEventListForDay.mock
}

//Set uses given function f to mock the EventRepository.GetEventListForDay method
func (mmGetEventListForDay *mEventRepositoryMockGetEventListForDay) Set(f func(ctx context.Context, date time.Time) (epa1 []*model.Event, err error)) *EventRepositoryMock {
	if mmGetEventListForDay.defaultExpectation != nil {
		mmGetEventListForDay.mock.t.Fatalf("Default expectation is already set for the EventRepository.GetEventListForDay method")
	}

	if len(mmGetEventListForDay.expectations) > 0 {
		mmGetEventListForDay.mock.t.Fatalf("Some expectations are already set for the EventRepository.GetEventListForDay method")
	}

	mmGetEventListForDay.mock.funcGetEventListForDay = f
	return mmGetEventListForDay.mock
}

// When sets expectation for the EventRepository.GetEventListForDay which will trigger the result defined by the following
// Then helper
func (mmGetEventListForDay *mEventRepositoryMockGetEventListForDay) When(ctx context.Context, date time.Time) *EventRepositoryMockGetEventListForDayExpectation {
	if mmGetEventListForDay.mock.funcGetEventListForDay != nil {
		mmGetEventListForDay.mock.t.Fatalf("EventRepositoryMock.GetEventListForDay mock is already set by Set")
	}

	expectation := &EventRepositoryMockGetEventListForDayExpectation{
		mock:   mmGetEventListForDay.mock,
		params: &EventRepositoryMockGetEventListForDayParams{ctx, date},
	}
	mmGetEventListForDay.expectations = append(mmGetEventListForDay.expectations, expectation)
	return expectation
}

// Then sets up EventRepository.GetEventListForDay return parameters for the expectation previously defined by the When method
func (e *EventRepositoryMockGetEventListForDayExpectation) Then(epa1 []*model.Event, err error) *EventRepositoryMock {
	e.results = &EventRepositoryMockGetEventListForDayResults{epa1, err}
	return e.mock
}

// GetEventListForDay implements repository.EventRepository
func (mmGetEventListForDay *EventRepositoryMock) GetEventListForDay(ctx context.Context, date time.Time) (epa1 []*model.Event, err error) {
	mm_atomic.AddUint64(&mmGetEventListForDay.beforeGetEventListForDayCounter, 1)
	defer mm_atomic.AddUint64(&mmGetEventListForDay.afterGetEventListForDayCounter, 1)

	if mmGetEventListForDay.inspectFuncGetEventListForDay != nil {
		mmGetEventListForDay.inspectFuncGetEventListForDay(ctx, date)
	}

	mm_params := &EventRepositoryMockGetEventListForDayParams{ctx, date}

	// Record call args
	mmGetEventListForDay.GetEventListForDayMock.mutex.Lock()
	mmGetEventListForDay.GetEventListForDayMock.callArgs = append(mmGetEventListForDay.GetEventListForDayMock.callArgs, mm_params)
	mmGetEventListForDay.GetEventListForDayMock.mutex.Unlock()

	for _, e := range mmGetEventListForDay.GetEventListForDayMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.epa1, e.results.err
		}
	}

	if mmGetEventListForDay.GetEventListForDayMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetEventListForDay.GetEventListForDayMock.defaultExpectation.Counter, 1)
		mm_want := mmGetEventListForDay.GetEventListForDayMock.defaultExpectation.params
		mm_got := EventRepositoryMockGetEventListForDayParams{ctx, date}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetEventListForDay.t.Errorf("EventRepositoryMock.GetEventListForDay got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetEventListForDay.GetEventListForDayMock.defaultExpectation.results
		if mm_results == nil {
			mmGetEventListForDay.t.Fatal("No results are set for the EventRepositoryMock.GetEventListForDay")
		}
		return (*mm_results).epa1, (*mm_results).err
	}
	if mmGetEventListForDay.funcGetEventListForDay != nil {
		return mmGetEventListForDay.funcGetEventListForDay(ctx, date)
	}
	mmGetEventListForDay.t.Fatalf("Unexpected call to EventRepositoryMock.GetEventListForDay. %v %v", ctx, date)
	return
}

// GetEventListForDayAfterCounter returns a count of finished EventRepositoryMock.GetEventListForDay invocations
func (mmGetEventListForDay *EventRepositoryMock) GetEventListForDayAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEventListForDay.afterGetEventListForDayCounter)
}

// GetEventListForDayBeforeCounter returns a count of EventRepositoryMock.GetEventListForDay invocations
func (mmGetEventListForDay *EventRepositoryMock) GetEventListForDayBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEventListForDay.beforeGetEventListForDayCounter)
}

// Calls returns a list of arguments used in each call to EventRepositoryMock.GetEventListForDay.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetEventListForDay *mEventRepositoryMockGetEventListForDay) Calls() []*EventRepositoryMockGetEventListForDayParams {
	mmGetEventListForDay.mutex.RLock()

	argCopy := make([]*EventRepositoryMockGetEventListForDayParams, len(mmGetEventListForDay.callArgs))
	copy(argCopy, mmGetEventListForDay.callArgs)

	mmGetEventListForDay.mutex.RUnlock()

	return argCopy
}

// MinimockGetEventListForDayDone returns true if the count of the GetEventListForDay invocations corresponds
// the number of defined expectations
func (m *EventRepositoryMock) MinimockGetEventListForDayDone() bool {
	for _, e := range m.GetEventListForDayMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetEventListForDayMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetEventListForDayCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetEventListForDay != nil && mm_atomic.LoadUint64(&m.afterGetEventListForDayCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetEventListForDayInspect logs each unmet expectation
func (m *EventRepositoryMock) MinimockGetEventListForDayInspect() {
	for _, e := range m.GetEventListForDayMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EventRepositoryMock.GetEventListForDay with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetEventListForDayMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetEventListForDayCounter) < 1 {
		if m.GetEventListForDayMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EventRepositoryMock.GetEventListForDay")
		} else {
			m.t.Errorf("Expected call to EventRepositoryMock.GetEventListForDay with params: %#v", *m.GetEventListForDayMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetEventListForDay != nil && mm_atomic.LoadUint64(&m.afterGetEventListForDayCounter) < 1 {
		m.t.Error("Expected call to EventRepositoryMock.GetEventListForDay")
	}
}

type mEventRepositoryMockGetEventListForMonth struct {
	mock               *EventRepositoryMock
	defaultExpectation *EventRepositoryMockGetEventListForMonthExpectation
	expectations       []*EventRepositoryMockGetEventListForMonthExpectation

	callArgs []*EventRepositoryMockGetEventListForMonthParams
	mutex    sync.RWMutex
}

// EventRepositoryMockGetEventListForMonthExpectation specifies expectation struct of the EventRepository.GetEventListForMonth
type EventRepositoryMockGetEventListForMonthExpectation struct {
	mock    *EventRepositoryMock
	params  *EventRepositoryMockGetEventListForMonthParams
	results *EventRepositoryMockGetEventListForMonthResults
	Counter uint64
}

// EventRepositoryMockGetEventListForMonthParams contains parameters of the EventRepository.GetEventListForMonth
type EventRepositoryMockGetEventListForMonthParams struct {
	ctx        context.Context
	monthStart time.Time
}

// EventRepositoryMockGetEventListForMonthResults contains results of the EventRepository.GetEventListForMonth
type EventRepositoryMockGetEventListForMonthResults struct {
	epa1 []*model.Event
	err  error
}

// Expect sets up expected params for EventRepository.GetEventListForMonth
func (mmGetEventListForMonth *mEventRepositoryMockGetEventListForMonth) Expect(ctx context.Context, monthStart time.Time) *mEventRepositoryMockGetEventListForMonth {
	if mmGetEventListForMonth.mock.funcGetEventListForMonth != nil {
		mmGetEventListForMonth.mock.t.Fatalf("EventRepositoryMock.GetEventListForMonth mock is already set by Set")
	}

	if mmGetEventListForMonth.defaultExpectation == nil {
		mmGetEventListForMonth.defaultExpectation = &EventRepositoryMockGetEventListForMonthExpectation{}
	}

	mmGetEventListForMonth.defaultExpectation.params = &EventRepositoryMockGetEventListForMonthParams{ctx, monthStart}
	for _, e := range mmGetEventListForMonth.expectations {
		if minimock.Equal(e.params, mmGetEventListForMonth.defaultExpectation.params) {
			mmGetEventListForMonth.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetEventListForMonth.defaultExpectation.params)
		}
	}

	return mmGetEventListForMonth
}

// Inspect accepts an inspector function that has same arguments as the EventRepository.GetEventListForMonth
func (mmGetEventListForMonth *mEventRepositoryMockGetEventListForMonth) Inspect(f func(ctx context.Context, monthStart time.Time)) *mEventRepositoryMockGetEventListForMonth {
	if mmGetEventListForMonth.mock.inspectFuncGetEventListForMonth != nil {
		mmGetEventListForMonth.mock.t.Fatalf("Inspect function is already set for EventRepositoryMock.GetEventListForMonth")
	}

	mmGetEventListForMonth.mock.inspectFuncGetEventListForMonth = f

	return mmGetEventListForMonth
}

// Return sets up results that will be returned by EventRepository.GetEventListForMonth
func (mmGetEventListForMonth *mEventRepositoryMockGetEventListForMonth) Return(epa1 []*model.Event, err error) *EventRepositoryMock {
	if mmGetEventListForMonth.mock.funcGetEventListForMonth != nil {
		mmGetEventListForMonth.mock.t.Fatalf("EventRepositoryMock.GetEventListForMonth mock is already set by Set")
	}

	if mmGetEventListForMonth.defaultExpectation == nil {
		mmGetEventListForMonth.defaultExpectation = &EventRepositoryMockGetEventListForMonthExpectation{mock: mmGetEventListForMonth.mock}
	}
	mmGetEventListForMonth.defaultExpectation.results = &EventRepositoryMockGetEventListForMonthResults{epa1, err}
	return mmGetEventListForMonth.mock
}

//Set uses given function f to mock the EventRepository.GetEventListForMonth method
func (mmGetEventListForMonth *mEventRepositoryMockGetEventListForMonth) Set(f func(ctx context.Context, monthStart time.Time) (epa1 []*model.Event, err error)) *EventRepositoryMock {
	if mmGetEventListForMonth.defaultExpectation != nil {
		mmGetEventListForMonth.mock.t.Fatalf("Default expectation is already set for the EventRepository.GetEventListForMonth method")
	}

	if len(mmGetEventListForMonth.expectations) > 0 {
		mmGetEventListForMonth.mock.t.Fatalf("Some expectations are already set for the EventRepository.GetEventListForMonth method")
	}

	mmGetEventListForMonth.mock.funcGetEventListForMonth = f
	return mmGetEventListForMonth.mock
}

// When sets expectation for the EventRepository.GetEventListForMonth which will trigger the result defined by the following
// Then helper
func (mmGetEventListForMonth *mEventRepositoryMockGetEventListForMonth) When(ctx context.Context, monthStart time.Time) *EventRepositoryMockGetEventListForMonthExpectation {
	if mmGetEventListForMonth.mock.funcGetEventListForMonth != nil {
		mmGetEventListForMonth.mock.t.Fatalf("EventRepositoryMock.GetEventListForMonth mock is already set by Set")
	}

	expectation := &EventRepositoryMockGetEventListForMonthExpectation{
		mock:   mmGetEventListForMonth.mock,
		params: &EventRepositoryMockGetEventListForMonthParams{ctx, monthStart},
	}
	mmGetEventListForMonth.expectations = append(mmGetEventListForMonth.expectations, expectation)
	return expectation
}

// Then sets up EventRepository.GetEventListForMonth return parameters for the expectation previously defined by the When method
func (e *EventRepositoryMockGetEventListForMonthExpectation) Then(epa1 []*model.Event, err error) *EventRepositoryMock {
	e.results = &EventRepositoryMockGetEventListForMonthResults{epa1, err}
	return e.mock
}

// GetEventListForMonth implements repository.EventRepository
func (mmGetEventListForMonth *EventRepositoryMock) GetEventListForMonth(ctx context.Context, monthStart time.Time) (epa1 []*model.Event, err error) {
	mm_atomic.AddUint64(&mmGetEventListForMonth.beforeGetEventListForMonthCounter, 1)
	defer mm_atomic.AddUint64(&mmGetEventListForMonth.afterGetEventListForMonthCounter, 1)

	if mmGetEventListForMonth.inspectFuncGetEventListForMonth != nil {
		mmGetEventListForMonth.inspectFuncGetEventListForMonth(ctx, monthStart)
	}

	mm_params := &EventRepositoryMockGetEventListForMonthParams{ctx, monthStart}

	// Record call args
	mmGetEventListForMonth.GetEventListForMonthMock.mutex.Lock()
	mmGetEventListForMonth.GetEventListForMonthMock.callArgs = append(mmGetEventListForMonth.GetEventListForMonthMock.callArgs, mm_params)
	mmGetEventListForMonth.GetEventListForMonthMock.mutex.Unlock()

	for _, e := range mmGetEventListForMonth.GetEventListForMonthMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.epa1, e.results.err
		}
	}

	if mmGetEventListForMonth.GetEventListForMonthMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetEventListForMonth.GetEventListForMonthMock.defaultExpectation.Counter, 1)
		mm_want := mmGetEventListForMonth.GetEventListForMonthMock.defaultExpectation.params
		mm_got := EventRepositoryMockGetEventListForMonthParams{ctx, monthStart}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetEventListForMonth.t.Errorf("EventRepositoryMock.GetEventListForMonth got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetEventListForMonth.GetEventListForMonthMock.defaultExpectation.results
		if mm_results == nil {
			mmGetEventListForMonth.t.Fatal("No results are set for the EventRepositoryMock.GetEventListForMonth")
		}
		return (*mm_results).epa1, (*mm_results).err
	}
	if mmGetEventListForMonth.funcGetEventListForMonth != nil {
		return mmGetEventListForMonth.funcGetEventListForMonth(ctx, monthStart)
	}
	mmGetEventListForMonth.t.Fatalf("Unexpected call to EventRepositoryMock.GetEventListForMonth. %v %v", ctx, monthStart)
	return
}

// GetEventListForMonthAfterCounter returns a count of finished EventRepositoryMock.GetEventListForMonth invocations
func (mmGetEventListForMonth *EventRepositoryMock) GetEventListForMonthAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEventListForMonth.afterGetEventListForMonthCounter)
}

// GetEventListForMonthBeforeCounter returns a count of EventRepositoryMock.GetEventListForMonth invocations
func (mmGetEventListForMonth *EventRepositoryMock) GetEventListForMonthBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEventListForMonth.beforeGetEventListForMonthCounter)
}

// Calls returns a list of arguments used in each call to EventRepositoryMock.GetEventListForMonth.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetEventListForMonth *mEventRepositoryMockGetEventListForMonth) Calls() []*EventRepositoryMockGetEventListForMonthParams {
	mmGetEventListForMonth.mutex.RLock()

	argCopy := make([]*EventRepositoryMockGetEventListForMonthParams, len(mmGetEventListForMonth.callArgs))
	copy(argCopy, mmGetEventListForMonth.callArgs)

	mmGetEventListForMonth.mutex.RUnlock()

	return argCopy
}

// MinimockGetEventListForMonthDone returns true if the count of the GetEventListForMonth invocations corresponds
// the number of defined expectations
func (m *EventRepositoryMock) MinimockGetEventListForMonthDone() bool {
	for _, e := range m.GetEventListForMonthMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetEventListForMonthMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetEventListForMonthCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetEventListForMonth != nil && mm_atomic.LoadUint64(&m.afterGetEventListForMonthCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetEventListForMonthInspect logs each unmet expectation
func (m *EventRepositoryMock) MinimockGetEventListForMonthInspect() {
	for _, e := range m.GetEventListForMonthMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EventRepositoryMock.GetEventListForMonth with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetEventListForMonthMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetEventListForMonthCounter) < 1 {
		if m.GetEventListForMonthMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EventRepositoryMock.GetEventListForMonth")
		} else {
			m.t.Errorf("Expected call to EventRepositoryMock.GetEventListForMonth with params: %#v", *m.GetEventListForMonthMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetEventListForMonth != nil && mm_atomic.LoadUint64(&m.afterGetEventListForMonthCounter) < 1 {
		m.t.Error("Expected call to EventRepositoryMock.GetEventListForMonth")
	}
}

type mEventRepositoryMockGetEventListForWeek struct {
	mock               *EventRepositoryMock
	defaultExpectation *EventRepositoryMockGetEventListForWeekExpectation
	expectations       []*EventRepositoryMockGetEventListForWeekExpectation

	callArgs []*EventRepositoryMockGetEventListForWeekParams
	mutex    sync.RWMutex
}

// EventRepositoryMockGetEventListForWeekExpectation specifies expectation struct of the EventRepository.GetEventListForWeek
type EventRepositoryMockGetEventListForWeekExpectation struct {
	mock    *EventRepositoryMock
	params  *EventRepositoryMockGetEventListForWeekParams
	results *EventRepositoryMockGetEventListForWeekResults
	Counter uint64
}

// EventRepositoryMockGetEventListForWeekParams contains parameters of the EventRepository.GetEventListForWeek
type EventRepositoryMockGetEventListForWeekParams struct {
	ctx       context.Context
	weekStart time.Time
}

// EventRepositoryMockGetEventListForWeekResults contains results of the EventRepository.GetEventListForWeek
type EventRepositoryMockGetEventListForWeekResults struct {
	epa1 []*model.Event
	err  error
}

// Expect sets up expected params for EventRepository.GetEventListForWeek
func (mmGetEventListForWeek *mEventRepositoryMockGetEventListForWeek) Expect(ctx context.Context, weekStart time.Time) *mEventRepositoryMockGetEventListForWeek {
	if mmGetEventListForWeek.mock.funcGetEventListForWeek != nil {
		mmGetEventListForWeek.mock.t.Fatalf("EventRepositoryMock.GetEventListForWeek mock is already set by Set")
	}

	if mmGetEventListForWeek.defaultExpectation == nil {
		mmGetEventListForWeek.defaultExpectation = &EventRepositoryMockGetEventListForWeekExpectation{}
	}

	mmGetEventListForWeek.defaultExpectation.params = &EventRepositoryMockGetEventListForWeekParams{ctx, weekStart}
	for _, e := range mmGetEventListForWeek.expectations {
		if minimock.Equal(e.params, mmGetEventListForWeek.defaultExpectation.params) {
			mmGetEventListForWeek.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetEventListForWeek.defaultExpectation.params)
		}
	}

	return mmGetEventListForWeek
}

// Inspect accepts an inspector function that has same arguments as the EventRepository.GetEventListForWeek
func (mmGetEventListForWeek *mEventRepositoryMockGetEventListForWeek) Inspect(f func(ctx context.Context, weekStart time.Time)) *mEventRepositoryMockGetEventListForWeek {
	if mmGetEventListForWeek.mock.inspectFuncGetEventListForWeek != nil {
		mmGetEventListForWeek.mock.t.Fatalf("Inspect function is already set for EventRepositoryMock.GetEventListForWeek")
	}

	mmGetEventListForWeek.mock.inspectFuncGetEventListForWeek = f

	return mmGetEventListForWeek
}

// Return sets up results that will be returned by EventRepository.GetEventListForWeek
func (mmGetEventListForWeek *mEventRepositoryMockGetEventListForWeek) Return(epa1 []*model.Event, err error) *EventRepositoryMock {
	if mmGetEventListForWeek.mock.funcGetEventListForWeek != nil {
		mmGetEventListForWeek.mock.t.Fatalf("EventRepositoryMock.GetEventListForWeek mock is already set by Set")
	}

	if mmGetEventListForWeek.defaultExpectation == nil {
		mmGetEventListForWeek.defaultExpectation = &EventRepositoryMockGetEventListForWeekExpectation{mock: mmGetEventListForWeek.mock}
	}
	mmGetEventListForWeek.defaultExpectation.results = &EventRepositoryMockGetEventListForWeekResults{epa1, err}
	return mmGetEventListForWeek.mock
}

//Set uses given function f to mock the EventRepository.GetEventListForWeek method
func (mmGetEventListForWeek *mEventRepositoryMockGetEventListForWeek) Set(f func(ctx context.Context, weekStart time.Time) (epa1 []*model.Event, err error)) *EventRepositoryMock {
	if mmGetEventListForWeek.defaultExpectation != nil {
		mmGetEventListForWeek.mock.t.Fatalf("Default expectation is already set for the EventRepository.GetEventListForWeek method")
	}

	if len(mmGetEventListForWeek.expectations) > 0 {
		mmGetEventListForWeek.mock.t.Fatalf("Some expectations are already set for the EventRepository.GetEventListForWeek method")
	}

	mmGetEventListForWeek.mock.funcGetEventListForWeek = f
	return mmGetEventListForWeek.mock
}

// When sets expectation for the EventRepository.GetEventListForWeek which will trigger the result defined by the following
// Then helper
func (mmGetEventListForWeek *mEventRepositoryMockGetEventListForWeek) When(ctx context.Context, weekStart time.Time) *EventRepositoryMockGetEventListForWeekExpectation {
	if mmGetEventListForWeek.mock.funcGetEventListForWeek != nil {
		mmGetEventListForWeek.mock.t.Fatalf("EventRepositoryMock.GetEventListForWeek mock is already set by Set")
	}

	expectation := &EventRepositoryMockGetEventListForWeekExpectation{
		mock:   mmGetEventListForWeek.mock,
		params: &EventRepositoryMockGetEventListForWeekParams{ctx, weekStart},
	}
	mmGetEventListForWeek.expectations = append(mmGetEventListForWeek.expectations, expectation)
	return expectation
}

// Then sets up EventRepository.GetEventListForWeek return parameters for the expectation previously defined by the When method
func (e *EventRepositoryMockGetEventListForWeekExpectation) Then(epa1 []*model.Event, err error) *EventRepositoryMock {
	e.results = &EventRepositoryMockGetEventListForWeekResults{epa1, err}
	return e.mock
}

// GetEventListForWeek implements repository.EventRepository
func (mmGetEventListForWeek *EventRepositoryMock) GetEventListForWeek(ctx context.Context, weekStart time.Time) (epa1 []*model.Event, err error) {
	mm_atomic.AddUint64(&mmGetEventListForWeek.beforeGetEventListForWeekCounter, 1)
	defer mm_atomic.AddUint64(&mmGetEventListForWeek.afterGetEventListForWeekCounter, 1)

	if mmGetEventListForWeek.inspectFuncGetEventListForWeek != nil {
		mmGetEventListForWeek.inspectFuncGetEventListForWeek(ctx, weekStart)
	}

	mm_params := &EventRepositoryMockGetEventListForWeekParams{ctx, weekStart}

	// Record call args
	mmGetEventListForWeek.GetEventListForWeekMock.mutex.Lock()
	mmGetEventListForWeek.GetEventListForWeekMock.callArgs = append(mmGetEventListForWeek.GetEventListForWeekMock.callArgs, mm_params)
	mmGetEventListForWeek.GetEventListForWeekMock.mutex.Unlock()

	for _, e := range mmGetEventListForWeek.GetEventListForWeekMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.epa1, e.results.err
		}
	}

	if mmGetEventListForWeek.GetEventListForWeekMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetEventListForWeek.GetEventListForWeekMock.defaultExpectation.Counter, 1)
		mm_want := mmGetEventListForWeek.GetEventListForWeekMock.defaultExpectation.params
		mm_got := EventRepositoryMockGetEventListForWeekParams{ctx, weekStart}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetEventListForWeek.t.Errorf("EventRepositoryMock.GetEventListForWeek got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetEventListForWeek.GetEventListForWeekMock.defaultExpectation.results
		if mm_results == nil {
			mmGetEventListForWeek.t.Fatal("No results are set for the EventRepositoryMock.GetEventListForWeek")
		}
		return (*mm_results).epa1, (*mm_results).err
	}
	if mmGetEventListForWeek.funcGetEventListForWeek != nil {
		return mmGetEventListForWeek.funcGetEventListForWeek(ctx, weekStart)
	}
	mmGetEventListForWeek.t.Fatalf("Unexpected call to EventRepositoryMock.GetEventListForWeek. %v %v", ctx, weekStart)
	return
}

// GetEventListForWeekAfterCounter returns a count of finished EventRepositoryMock.GetEventListForWeek invocations
func (mmGetEventListForWeek *EventRepositoryMock) GetEventListForWeekAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEventListForWeek.afterGetEventListForWeekCounter)
}

// GetEventListForWeekBeforeCounter returns a count of EventRepositoryMock.GetEventListForWeek invocations
func (mmGetEventListForWeek *EventRepositoryMock) GetEventListForWeekBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetEventListForWeek.beforeGetEventListForWeekCounter)
}

// Calls returns a list of arguments used in each call to EventRepositoryMock.GetEventListForWeek.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetEventListForWeek *mEventRepositoryMockGetEventListForWeek) Calls() []*EventRepositoryMockGetEventListForWeekParams {
	mmGetEventListForWeek.mutex.RLock()

	argCopy := make([]*EventRepositoryMockGetEventListForWeekParams, len(mmGetEventListForWeek.callArgs))
	copy(argCopy, mmGetEventListForWeek.callArgs)

	mmGetEventListForWeek.mutex.RUnlock()

	return argCopy
}

// MinimockGetEventListForWeekDone returns true if the count of the GetEventListForWeek invocations corresponds
// the number of defined expectations
func (m *EventRepositoryMock) MinimockGetEventListForWeekDone() bool {
	for _, e := range m.GetEventListForWeekMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetEventListForWeekMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetEventListForWeekCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetEventListForWeek != nil && mm_atomic.LoadUint64(&m.afterGetEventListForWeekCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetEventListForWeekInspect logs each unmet expectation
func (m *EventRepositoryMock) MinimockGetEventListForWeekInspect() {
	for _, e := range m.GetEventListForWeekMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EventRepositoryMock.GetEventListForWeek with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetEventListForWeekMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetEventListForWeekCounter) < 1 {
		if m.GetEventListForWeekMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EventRepositoryMock.GetEventListForWeek")
		} else {
			m.t.Errorf("Expected call to EventRepositoryMock.GetEventListForWeek with params: %#v", *m.GetEventListForWeekMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetEventListForWeek != nil && mm_atomic.LoadUint64(&m.afterGetEventListForWeekCounter) < 1 {
		m.t.Error("Expected call to EventRepositoryMock.GetEventListForWeek")
	}
}

type mEventRepositoryMockUpdateEvent struct {
	mock               *EventRepositoryMock
	defaultExpectation *EventRepositoryMockUpdateEventExpectation
	expectations       []*EventRepositoryMockUpdateEventExpectation

	callArgs []*EventRepositoryMockUpdateEventParams
	mutex    sync.RWMutex
}

// EventRepositoryMockUpdateEventExpectation specifies expectation struct of the EventRepository.UpdateEvent
type EventRepositoryMockUpdateEventExpectation struct {
	mock    *EventRepositoryMock
	params  *EventRepositoryMockUpdateEventParams
	results *EventRepositoryMockUpdateEventResults
	Counter uint64
}

// EventRepositoryMockUpdateEventParams contains parameters of the EventRepository.UpdateEvent
type EventRepositoryMockUpdateEventParams struct {
	ctx             context.Context
	eventID         int64
	updateEventInfo *model.UpdateEventInfo
}

// EventRepositoryMockUpdateEventResults contains results of the EventRepository.UpdateEvent
type EventRepositoryMockUpdateEventResults struct {
	err error
}

// Expect sets up expected params for EventRepository.UpdateEvent
func (mmUpdateEvent *mEventRepositoryMockUpdateEvent) Expect(ctx context.Context, eventID int64, updateEventInfo *model.UpdateEventInfo) *mEventRepositoryMockUpdateEvent {
	if mmUpdateEvent.mock.funcUpdateEvent != nil {
		mmUpdateEvent.mock.t.Fatalf("EventRepositoryMock.UpdateEvent mock is already set by Set")
	}

	if mmUpdateEvent.defaultExpectation == nil {
		mmUpdateEvent.defaultExpectation = &EventRepositoryMockUpdateEventExpectation{}
	}

	mmUpdateEvent.defaultExpectation.params = &EventRepositoryMockUpdateEventParams{ctx, eventID, updateEventInfo}
	for _, e := range mmUpdateEvent.expectations {
		if minimock.Equal(e.params, mmUpdateEvent.defaultExpectation.params) {
			mmUpdateEvent.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateEvent.defaultExpectation.params)
		}
	}

	return mmUpdateEvent
}

// Inspect accepts an inspector function that has same arguments as the EventRepository.UpdateEvent
func (mmUpdateEvent *mEventRepositoryMockUpdateEvent) Inspect(f func(ctx context.Context, eventID int64, updateEventInfo *model.UpdateEventInfo)) *mEventRepositoryMockUpdateEvent {
	if mmUpdateEvent.mock.inspectFuncUpdateEvent != nil {
		mmUpdateEvent.mock.t.Fatalf("Inspect function is already set for EventRepositoryMock.UpdateEvent")
	}

	mmUpdateEvent.mock.inspectFuncUpdateEvent = f

	return mmUpdateEvent
}

// Return sets up results that will be returned by EventRepository.UpdateEvent
func (mmUpdateEvent *mEventRepositoryMockUpdateEvent) Return(err error) *EventRepositoryMock {
	if mmUpdateEvent.mock.funcUpdateEvent != nil {
		mmUpdateEvent.mock.t.Fatalf("EventRepositoryMock.UpdateEvent mock is already set by Set")
	}

	if mmUpdateEvent.defaultExpectation == nil {
		mmUpdateEvent.defaultExpectation = &EventRepositoryMockUpdateEventExpectation{mock: mmUpdateEvent.mock}
	}
	mmUpdateEvent.defaultExpectation.results = &EventRepositoryMockUpdateEventResults{err}
	return mmUpdateEvent.mock
}

//Set uses given function f to mock the EventRepository.UpdateEvent method
func (mmUpdateEvent *mEventRepositoryMockUpdateEvent) Set(f func(ctx context.Context, eventID int64, updateEventInfo *model.UpdateEventInfo) (err error)) *EventRepositoryMock {
	if mmUpdateEvent.defaultExpectation != nil {
		mmUpdateEvent.mock.t.Fatalf("Default expectation is already set for the EventRepository.UpdateEvent method")
	}

	if len(mmUpdateEvent.expectations) > 0 {
		mmUpdateEvent.mock.t.Fatalf("Some expectations are already set for the EventRepository.UpdateEvent method")
	}

	mmUpdateEvent.mock.funcUpdateEvent = f
	return mmUpdateEvent.mock
}

// When sets expectation for the EventRepository.UpdateEvent which will trigger the result defined by the following
// Then helper
func (mmUpdateEvent *mEventRepositoryMockUpdateEvent) When(ctx context.Context, eventID int64, updateEventInfo *model.UpdateEventInfo) *EventRepositoryMockUpdateEventExpectation {
	if mmUpdateEvent.mock.funcUpdateEvent != nil {
		mmUpdateEvent.mock.t.Fatalf("EventRepositoryMock.UpdateEvent mock is already set by Set")
	}

	expectation := &EventRepositoryMockUpdateEventExpectation{
		mock:   mmUpdateEvent.mock,
		params: &EventRepositoryMockUpdateEventParams{ctx, eventID, updateEventInfo},
	}
	mmUpdateEvent.expectations = append(mmUpdateEvent.expectations, expectation)
	return expectation
}

// Then sets up EventRepository.UpdateEvent return parameters for the expectation previously defined by the When method
func (e *EventRepositoryMockUpdateEventExpectation) Then(err error) *EventRepositoryMock {
	e.results = &EventRepositoryMockUpdateEventResults{err}
	return e.mock
}

// UpdateEvent implements repository.EventRepository
func (mmUpdateEvent *EventRepositoryMock) UpdateEvent(ctx context.Context, eventID int64, updateEventInfo *model.UpdateEventInfo) (err error) {
	mm_atomic.AddUint64(&mmUpdateEvent.beforeUpdateEventCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateEvent.afterUpdateEventCounter, 1)

	if mmUpdateEvent.inspectFuncUpdateEvent != nil {
		mmUpdateEvent.inspectFuncUpdateEvent(ctx, eventID, updateEventInfo)
	}

	mm_params := &EventRepositoryMockUpdateEventParams{ctx, eventID, updateEventInfo}

	// Record call args
	mmUpdateEvent.UpdateEventMock.mutex.Lock()
	mmUpdateEvent.UpdateEventMock.callArgs = append(mmUpdateEvent.UpdateEventMock.callArgs, mm_params)
	mmUpdateEvent.UpdateEventMock.mutex.Unlock()

	for _, e := range mmUpdateEvent.UpdateEventMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateEvent.UpdateEventMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateEvent.UpdateEventMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateEvent.UpdateEventMock.defaultExpectation.params
		mm_got := EventRepositoryMockUpdateEventParams{ctx, eventID, updateEventInfo}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateEvent.t.Errorf("EventRepositoryMock.UpdateEvent got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateEvent.UpdateEventMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateEvent.t.Fatal("No results are set for the EventRepositoryMock.UpdateEvent")
		}
		return (*mm_results).err
	}
	if mmUpdateEvent.funcUpdateEvent != nil {
		return mmUpdateEvent.funcUpdateEvent(ctx, eventID, updateEventInfo)
	}
	mmUpdateEvent.t.Fatalf("Unexpected call to EventRepositoryMock.UpdateEvent. %v %v %v", ctx, eventID, updateEventInfo)
	return
}

// UpdateEventAfterCounter returns a count of finished EventRepositoryMock.UpdateEvent invocations
func (mmUpdateEvent *EventRepositoryMock) UpdateEventAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateEvent.afterUpdateEventCounter)
}

// UpdateEventBeforeCounter returns a count of EventRepositoryMock.UpdateEvent invocations
func (mmUpdateEvent *EventRepositoryMock) UpdateEventBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateEvent.beforeUpdateEventCounter)
}

// Calls returns a list of arguments used in each call to EventRepositoryMock.UpdateEvent.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateEvent *mEventRepositoryMockUpdateEvent) Calls() []*EventRepositoryMockUpdateEventParams {
	mmUpdateEvent.mutex.RLock()

	argCopy := make([]*EventRepositoryMockUpdateEventParams, len(mmUpdateEvent.callArgs))
	copy(argCopy, mmUpdateEvent.callArgs)

	mmUpdateEvent.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateEventDone returns true if the count of the UpdateEvent invocations corresponds
// the number of defined expectations
func (m *EventRepositoryMock) MinimockUpdateEventDone() bool {
	for _, e := range m.UpdateEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateEventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateEventCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateEvent != nil && mm_atomic.LoadUint64(&m.afterUpdateEventCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateEventInspect logs each unmet expectation
func (m *EventRepositoryMock) MinimockUpdateEventInspect() {
	for _, e := range m.UpdateEventMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to EventRepositoryMock.UpdateEvent with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateEventMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateEventCounter) < 1 {
		if m.UpdateEventMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to EventRepositoryMock.UpdateEvent")
		} else {
			m.t.Errorf("Expected call to EventRepositoryMock.UpdateEvent with params: %#v", *m.UpdateEventMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateEvent != nil && mm_atomic.LoadUint64(&m.afterUpdateEventCounter) < 1 {
		m.t.Error("Expected call to EventRepositoryMock.UpdateEvent")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *EventRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateEventInspect()

		m.MinimockDeleteEventInspect()

		m.MinimockGetEventListByDateInspect()

		m.MinimockGetEventListForDayInspect()

		m.MinimockGetEventListForMonthInspect()

		m.MinimockGetEventListForWeekInspect()

		m.MinimockUpdateEventInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *EventRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *EventRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateEventDone() &&
		m.MinimockDeleteEventDone() &&
		m.MinimockGetEventListByDateDone() &&
		m.MinimockGetEventListForDayDone() &&
		m.MinimockGetEventListForMonthDone() &&
		m.MinimockGetEventListForWeekDone() &&
		m.MinimockUpdateEventDone()
}
